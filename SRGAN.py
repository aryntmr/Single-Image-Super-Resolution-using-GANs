# -*- coding: utf-8 -*-
"""self_self

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JGeEfEHB7rPEDXbdeB8ESmSBEAKTGs_k
"""

from os import listdir
from os.path import join

from PIL import Image
from torch.utils.data.dataset import Dataset
from torchvision.transforms import Compose, RandomCrop, ToTensor, ToPILImage, CenterCrop, Resize

import torch
from torch import nn
from torchvision.models.vgg import vgg19

import math
from math import exp

import torch
import torch.nn.functional as F
from torch.autograd import Variable

import argparse
import os
from math import log10

import pandas as pd
import torch.optim as optim
import torch.utils.data
import torchvision.utils as utils
from torch.autograd import Variable
from torch.utils.data import DataLoader
from tqdm import tqdm

from scipy.ndimage import zoom
from PIL import Image

from os import listdir
from os.path import join

from PIL import Image
from torch.utils.data.dataset import Dataset
from torchvision.transforms import Normalize, Compose, RandomCrop, ToTensor, ToPILImage, CenterCrop, Resize

def highres_transform_img(crop_size):
    return Compose([
        RandomCrop(crop_size),
        ToTensor(),
	Normalize([0, 0, 0], [1, 1, 1])
    ])


def lowres_transform_img(crop_size, upscale_factor):
    return Compose([
        ToPILImage(),
        Resize(crop_size // upscale_factor, interpolation=Image.BICUBIC),
        ToTensor(),
	Normalize([0, 0, 0], [1, 1, 1])
    ])


def display_transform():
    return Compose([
        ToPILImage(),
        Resize(400),
        CenterCrop(400),
        ToTensor()
    ])

class Train_transform(Dataset):
    def __init__(self, dataset_dir, crop_size, upscale_factor):
        super(Train_transform, self).__init__()
        self.image_filenames = [join(dataset_dir, x) for x in listdir(dataset_dir)]
        self.highres_transform = highres_transform_img(crop_size)
        self.lowres_transform = lowres_transform_img(crop_size, upscale_factor)

    def __getitem__(self, index):
        highres_image = self.highres_transform(Image.open(self.image_filenames[index]))
        lowres_image = self.lowres_transform(highres_image)
        return lowres_image, highres_image

    def __len__(self):
        return len(self.image_filenames)

class Val_transform(Dataset):
    def __init__(self, dataset_dir, upscale_factor):
        super(Val_transform, self).__init__()
        self.upscale_factor = upscale_factor
        self.image_filenames = [join(dataset_dir, x) for x in listdir(dataset_dir)[:5]] #if check_image_file(x)]


    def __getitem__(self, index):

        hr_image = Image.open(self.image_filenames[index])
        w, h = hr_image.size
        crop_size = 256
        lr_scale = Resize(crop_size // self.upscale_factor, interpolation=Image.BICUBIC)
        hr_scale = Resize(crop_size, interpolation=Image.BICUBIC)
        hr_image = hr_scale(hr_image)
        lr_image = lr_scale(hr_image)
        hr_restore_img = hr_scale(lr_image)
        hr_image = CenterCrop(crop_size)(hr_image)
        lr_image = CenterCrop(crop_size//4)(lr_image)
        hr_restore_img = CenterCrop(crop_size)(hr_restore_img)
        # print(f"crop_size: {crop_size}, w: {w}, h: {h}, low: ({lr_image.width},{lr_image.height}), Bicubic: ({hr_restore_img.width},{hr_restore_img.height}), high: ({hr_image.width},{hr_image.height})")

        return ToTensor()(lr_image), ToTensor()(hr_restore_img), ToTensor()(hr_image)
    def __len__(self):
        return len(self.image_filenames)

class GeneratorLoss(nn.Module):
    def __init__(self):
        super(GeneratorLoss, self).__init__()
        vgg = vgg19(pretrained=True)
        loss_network = nn.Sequential(*list(vgg.features)[:9]).eval()
        for param in loss_network.parameters():
            param.requires_grad = False
        self.loss_network = loss_network
        self.mse_loss = nn.MSELoss()
        self.tv_loss = TVLoss()

    def forward(self, out_labels, out_images, target_images):
        # Adversarial Loss
        adversarial_loss = torch.mean(1 - out_labels)
        # Perception Loss
        perception_loss = self.mse_loss(self.loss_network(out_images), self.loss_network(target_images))
        # Image Loss
        image_loss = self.mse_loss(out_images, target_images)
        # TV Loss
        tv_loss = self.tv_loss(out_images)
        return image_loss + 0.001 * adversarial_loss + 0.08 * perception_loss + 2e-8 * tv_loss


class TVLoss(nn.Module):
    def __init__(self, tv_loss_weight=1):
        super(TVLoss, self).__init__()
        self.tv_loss_weight = tv_loss_weight

    def forward(self, x):
        batch_size = x.size()[0]
        h_x = x.size()[2]
        w_x = x.size()[3]
        count_h = self.tensor_size(x[:, :, 1:, :])
        count_w = self.tensor_size(x[:, :, :, 1:])
        h_tv = torch.pow((x[:, :, 1:, :] - x[:, :, :h_x - 1, :]), 2).sum()
        w_tv = torch.pow((x[:, :, :, 1:] - x[:, :, :, :w_x - 1]), 2).sum()
        return self.tv_loss_weight * 2 * (h_tv / count_h + w_tv / count_w) / batch_size

    @staticmethod
    def tensor_size(t):
        return t.size()[1] * t.size()[2] * t.size()[3]

"""#Youtube

"""

# import torch
# from torch import nn


# class ConvBlock(nn.Module):
#     def __init__(
#         self,
#         in_channels,
#         out_channels,
#         discriminator=False,
#         use_act=True,
#         use_bn=True,
#         **kwargs,
#     ):
#         super().__init__()
#         self.use_act = use_act
#         self.cnn = nn.Conv2d(in_channels, out_channels, **kwargs, bias=not use_bn)
#         self.bn = nn.BatchNorm2d(out_channels) if use_bn else nn.Identity()
#         self.act = (
#             nn.LeakyReLU(0.2, inplace=True)
#             if discriminator
#             else nn.PReLU(num_parameters=out_channels)
#         )

#     def forward(self, x):
#         return self.act(self.bn(self.cnn(x))) if self.use_act else self.bn(self.cnn(x))


# class UpsampleBlock(nn.Module):
#     def __init__(self, in_c, scale_factor):
#         super().__init__()
#         self.conv = nn.Conv2d(in_c, in_c * scale_factor ** 2, 3, 1, 1)
#         self.ps = nn.PixelShuffle(scale_factor)  # in_c * 4, H, W --> in_c, H*2, W*2
#         self.act = nn.PReLU(num_parameters=in_c)

#     def forward(self, x):
#         return self.act(self.ps(self.conv(x)))


# class ResidualBlock(nn.Module):
#     def __init__(self, in_channels):
#         super().__init__()
#         self.block1 = ConvBlock(
#             in_channels,
#             in_channels,
#             kernel_size=3,
#             stride=1,
#             padding=1
#         )
#         self.block2 = ConvBlock(
#             in_channels,
#             in_channels,
#             kernel_size=3,
#             stride=1,
#             padding=1,
#             use_act=False,
#         )

#     def forward(self, x):
#         out = self.block1(x)
#         out = self.block2(out)
#         return out + x


# class Generator(nn.Module):
#     def __init__(self, in_channels=3, num_channels=64, num_blocks=16):
#         super().__init__()
#         self.initial = ConvBlock(in_channels, num_channels, kernel_size=9, stride=1, padding=4, use_bn=False)
#         self.residuals = nn.Sequential(*[ResidualBlock(num_channels) for _ in range(num_blocks)])
#         self.convblock = ConvBlock(num_channels, num_channels, kernel_size=3, stride=1, padding=1, use_act=False)
#         self.upsamples = nn.Sequential(UpsampleBlock(num_channels, 2), UpsampleBlock(num_channels, 2))
#         self.final = nn.Conv2d(num_channels, in_channels, kernel_size=9, stride=1, padding=4)

#     def forward(self, x):
#         initial = self.initial(x)
#         x = self.residuals(initial)
#         x = self.convblock(x) + initial
#         x = self.upsamples(x)
#         return torch.tanh(self.final(x))


# class Discriminator(nn.Module):
#     def __init__(self, in_channels=3, features=[64, 64, 128, 128, 256, 256, 512, 512]):
#         super().__init__()
#         blocks = []
#         for idx, feature in enumerate(features):
#             blocks.append(
#                 ConvBlock(
#                     in_channels,
#                     feature,
#                     kernel_size=3,
#                     stride=1 + idx % 2,
#                     padding=1,
#                     discriminator=True,
#                     use_act=True,
#                     use_bn=False if idx == 0 else True,
#                 )
#             )
#             in_channels = feature

#         self.blocks = nn.Sequential(*blocks)
#         self.classifier = nn.Sequential(
#             nn.AdaptiveAvgPool2d((6, 6)),
#             nn.Flatten(),
#             nn.Linear(512*6*6, 1024),
#             nn.LeakyReLU(0.2, inplace=True),
#             nn.Linear(1024, 1),
#         )

#     def forward(self, x):
#         x = self.blocks(x)
#         return self.classifier(x)


# low_resolution = 24  # 96x96 -> 24x24
# with torch.cuda.amp.autocast():
#     x = torch.randn((5, 3, low_resolution, low_resolution))
#     gen = Generator()
#     gen_out = gen(x)
#     disc = Discriminator()
#     disc_out = disc(gen_out)

#     print(gen_out.shape)
#     print(disc_out)

"""#Self

"""

class Convolution(nn.Module):
    def __init__(
        self,
        in_channels,
        out_channels,
        kernel_size,
        stride,
        padding,
        batch_norm = True,
        is_discriminator = False,
        use_activation = True,
        ):
        super().__init__()
        self.use_activation = use_activation
        self.is_discriminator = is_discriminator
        self.out_channels = out_channels

        self.conv = nn.Sequential(
            nn.Conv2d(
                in_channels = in_channels,
                out_channels = out_channels,
                bias = not batch_norm,
                kernel_size = kernel_size,
                stride = stride,
                padding = padding,
                ),
            nn.BatchNorm2d(out_channels) if batch_norm else nn.Identity(),
        )
        self.activation = (
            nn.LeakyReLU(0.2, inplace=True)
            if is_discriminator
            else nn.PReLU(num_parameters=out_channels)
        )
        self.weight = nn.Parameter(torch.Tensor(out_channels))

    def forward(self, x):
        return self.activation(self.conv(x)) if self.use_activation else self.conv(x)
#         if self.use_activation:
#             if self.is_discriminator:
#                 return F.leaky_relu(self.conv(x), 0.2, inplace=True)
#             else:
#                 return F.prelu(self.conv(x), weight = self.weight)
#         else:
#             return self.conv(x)

class Upsample(nn.Module):
    def __init__(self, in_channels, scale_factor = 4):
        super().__init__()
        self.in_channels = in_channels
        self.conv = nn.Sequential(
            nn.Conv2d(
                in_channels = in_channels,
                out_channels = in_channels * scale_factor ** 2,
                kernel_size = 3,
                stride = 1,
                padding = 1,
            ),
            nn.PixelShuffle(scale_factor),
        )
        self.activation = nn.PReLU(num_parameters=in_channels)

#         self.weight = nn.Parameter(torch.Tensor(in_channels))
#         self.weight = nn.Parameter(torch.empty(in_channels * scale_factor ** 2).fill_(0.25))

    def forward(self, x):
        x= self.conv(x)
        return self.activation(x)

class Residual(nn.Module):
    def __init__(self, in_channels):
        super().__init__()
        self.residual = nn.Sequential(
            Convolution(
                in_channels = in_channels,
                out_channels = in_channels,
                kernel_size = 3,
                stride = 1,
                padding = 1,
            ),
            Convolution(
                in_channels = in_channels,
                out_channels = in_channels,
                kernel_size = 3,
                stride = 1,
                padding = 1,
                use_activation = False,
            ),
        )

    def forward(self, x):
        out = self.residual(x)
        return out + x

class Generator(nn.Module):
    def __init__(self, in_channels=3, out_channels=64, num_blocks=10, scale_factor=4):
        super().__init__()

        self.initial = Convolution(
            in_channels = in_channels,
            out_channels = out_channels,
            kernel_size = 9,
            stride = 1,
            padding = 4,
            batch_norm=False,

        )

        self.residuals = nn.Sequential(
            *[Residual(out_channels) for _ in range(num_blocks)]
        )

        self.post_residual = Convolution(
            in_channels = out_channels,
            out_channels = out_channels,
            kernel_size = 3,
            stride = 1,
            padding = 1,
            use_activation = False,
        )

        self.upsample = nn.Sequential(
            *[Upsample(out_channels, 2) for _ in range(scale_factor//2)],
            nn.Conv2d(
                in_channels = out_channels,
                out_channels = in_channels,
                kernel_size = 9,
                stride = 1,
                padding = 4,
            ),
        )


    def forward(self, x):
        initial = self.initial(x)
        residuals = self.residuals(initial)
        post_residual = self.post_residual(residuals) + initial
        upsample = self.upsample(post_residual)
        return F.tanh(upsample)

class Discriminator(nn.Module):
    def __init__(self, in_channels=3):
        super().__init__()
        features = [64, 64, 128, 128, 256, 256, 512, 512]
        blocks = []
        for i, feature in enumerate(features):
            blocks.append(
                Convolution(
                    in_channels = in_channels,
                    out_channels = feature,
                    kernel_size = 3,
                    stride = 1 + (i % 2),
                    padding = 1,
                    is_discriminator = True,
                    use_activation = True,
                    batch_norm = True if i != 0 else False,
                )
            )
            in_channels = feature

        self.classifier = nn.Sequential(
            *[(block) for block in blocks],
            nn.AdaptiveAvgPool2d((6, 6)),
            nn.Flatten(),
            nn.Linear(512*6*6, 1024),
            nn.LeakyReLU(0.2, inplace=True),
            nn.Linear(1024, 1),
        )

    def forward(self, x):
        batch_size = x.size(0)
        return torch.sigmoid(self.classifier(x).view(batch_size))
        # return self.classifier(x)

# class Discriminator(nn.Module):
#     def __init__(self, in_channels=3, features=[64, 64, 128, 128, 256, 256, 512, 512]):
#         super().__init__()
#         blocks = []
#         for idx, feature in enumerate(features):
#             blocks.append(
#                 Convolution(
#                     in_channels,
#                     feature,
#                     kernel_size=3,
#                     stride=1 + idx % 2,
#                     padding=1,
#                     is_discriminator=True,
#                     use_activation=True,
#                     batch_norm=False if idx == 0 else True,
#                 )
#             )
#             in_channels = feature

#         self.blocks = nn.Sequential(*blocks)
#         self.classifier = nn.Sequential(
#             nn.AdaptiveAvgPool2d((6, 6)),
#             nn.Flatten(),
#             nn.Linear(512*6*6, 1024),
#             nn.LeakyReLU(0.2, inplace=True),
#             nn.Linear(1024, 1),
#         )

#     def forward(self, x):
#         x = self.blocks(x)
#         return self.classifier(x)
# #         return F.sigmoid(self.classifier(x))

# a = Generator()
# print(a)
# b= Discriminator()
# print(b)

# x = torch.randn((5, 3, 64, 64))
# gen = Generator()
# gen_out = gen(x)
# disc = Discriminator()
# disc_out = disc(gen_out)

# print(gen_out.shape)
# print(disc_out)

"""# Github"""

# class Generator(nn.Module):
#     def __init__(self, scale_factor = 4):
#         upsample_block_num = int(math.log(scale_factor, 2))

#         super(Generator, self).__init__()
#         self.block1 = nn.Sequential(
#             nn.Conv2d(3, 64, kernel_size=9, padding=4),
#             nn.PReLU()
#         )
#         self.block2 = ResidualBlock(64)
#         self.block3 = ResidualBlock(64)
#         self.block4 = ResidualBlock(64)
#         self.block5 = ResidualBlock(64)
#         self.block6 = ResidualBlock(64)
#         self.block7 = nn.Sequential(
#             nn.Conv2d(64, 64, kernel_size=3, padding=1),
#             nn.BatchNorm2d(64)
#         )
#         block8 = [UpsampleBLock(64, 2) for _ in range(upsample_block_num)]
#         block8.append(nn.Conv2d(64, 3, kernel_size=9, padding=4))
#         self.block8 = nn.Sequential(*block8)

#     def forward(self, x):
#         block1 = self.block1(x)
#         block2 = self.block2(block1)
#         block3 = self.block3(block2)
#         block4 = self.block4(block3)
#         block5 = self.block5(block4)
#         block6 = self.block6(block5)
#         block7 = self.block7(block6)
#         block8 = self.block8(block1 + block7)

#         return (torch.tanh(block8) + 1) / 2


# class Discriminator(nn.Module):
#     def __init__(self):
#         super(Discriminator, self).__init__()
#         self.net = nn.Sequential(
#             nn.Conv2d(3, 64, kernel_size=3, padding=1),
#             nn.LeakyReLU(0.2),

#             nn.Conv2d(64, 64, kernel_size=3, stride=2, padding=1),
#             nn.BatchNorm2d(64),
#             nn.LeakyReLU(0.2),

#             nn.Conv2d(64, 128, kernel_size=3, padding=1),
#             nn.BatchNorm2d(128),
#             nn.LeakyReLU(0.2),

#             nn.Conv2d(128, 128, kernel_size=3, stride=2, padding=1),
#             nn.BatchNorm2d(128),
#             nn.LeakyReLU(0.2),

#             nn.Conv2d(128, 256, kernel_size=3, padding=1),
#             nn.BatchNorm2d(256),
#             nn.LeakyReLU(0.2),

#             nn.Conv2d(256, 256, kernel_size=3, stride=2, padding=1),
#             nn.BatchNorm2d(256),
#             nn.LeakyReLU(0.2),

#             nn.Conv2d(256, 512, kernel_size=3, padding=1),
#             nn.BatchNorm2d(512),
#             nn.LeakyReLU(0.2),

#             nn.Conv2d(512, 512, kernel_size=3, stride=2, padding=1),
#             nn.BatchNorm2d(512),
#             nn.LeakyReLU(0.2),

#             nn.AdaptiveAvgPool2d(1),
#             nn.Conv2d(512, 1024, kernel_size=1),
#             nn.LeakyReLU(0.2),
#             nn.Conv2d(1024, 1, kernel_size=1)
#         )

#     def forward(self, x):
#         batch_size = x.size(0)
#         return torch.sigmoid(self.net(x).view(batch_size))


# class ResidualBlock(nn.Module):
#     def __init__(self, channels):
#         super(ResidualBlock, self).__init__()
#         self.conv1 = nn.Conv2d(channels, channels, kernel_size=3, padding=1)
#         self.bn1 = nn.BatchNorm2d(channels)
#         self.prelu = nn.PReLU()
#         self.conv2 = nn.Conv2d(channels, channels, kernel_size=3, padding=1)
#         self.bn2 = nn.BatchNorm2d(channels)

#     def forward(self, x):
#         residual = self.conv1(x)
#         residual = self.bn1(residual)
#         residual = self.prelu(residual)
#         residual = self.conv2(residual)
#         residual = self.bn2(residual)

#         return x + residual


# class UpsampleBLock(nn.Module):
#     def __init__(self, in_channels, up_scale):
#         super(UpsampleBLock, self).__init__()
#         self.conv = nn.Conv2d(in_channels, in_channels * up_scale ** 2, kernel_size=3, padding=1)
#         self.pixel_shuffle = nn.PixelShuffle(up_scale)
#         self.prelu = nn.PReLU()

#     def forward(self, x):
#         x = self.conv(x)
#         x = self.pixel_shuffle(x)
#         x = self.prelu(x)
#         return x

def gaussian(window_size, sigma):
    gauss = torch.Tensor([exp(-(x - window_size // 2) ** 2 / float(2 * sigma ** 2)) for x in range(window_size)])
    return gauss / gauss.sum()


def create_window(window_size, channel):
    _1D_window = gaussian(window_size, 1.5).unsqueeze(1)
    _2D_window = _1D_window.mm(_1D_window.t()).float().unsqueeze(0).unsqueeze(0)
    window = Variable(_2D_window.expand(channel, 1, window_size, window_size).contiguous())
    return window


def _ssim(img1, img2, window, window_size, channel, size_average=True):
    mu1 = F.conv2d(img1, window, padding=window_size // 2, groups=channel)
    mu2 = F.conv2d(img2, window, padding=window_size // 2, groups=channel)

    mu1_sq = mu1.pow(2)
    mu2_sq = mu2.pow(2)
    mu1_mu2 = mu1 * mu2

    sigma1_sq = F.conv2d(img1 * img1, window, padding=window_size // 2, groups=channel) - mu1_sq
    sigma2_sq = F.conv2d(img2 * img2, window, padding=window_size // 2, groups=channel) - mu2_sq
    sigma12 = F.conv2d(img1 * img2, window, padding=window_size // 2, groups=channel) - mu1_mu2

    C1 = 0.01 ** 2
    C2 = 0.03 ** 2

    ssim_map = ((2 * mu1_mu2 + C1) * (2 * sigma12 + C2)) / ((mu1_sq + mu2_sq + C1) * (sigma1_sq + sigma2_sq + C2))

    if size_average:
        return ssim_map.mean()
    else:
        return ssim_map.mean(1).mean(1).mean(1)


class SSIM(torch.nn.Module):
    def __init__(self, window_size=11, size_average=True):
        super(SSIM, self).__init__()
        self.window_size = window_size
        self.size_average = size_average
        self.channel = 1
        self.window = create_window(window_size, self.channel)

    def forward(self, img1, img2):
        (_, channel, _, _) = img1.size()

        if channel == self.channel and self.window.data.type() == img1.data.type():
            window = self.window
        else:
            window = create_window(self.window_size, channel)

            if img1.is_cuda:
                window = window.cuda(img1.get_device())
            window = window.type_as(img1)

            self.window = window
            self.channel = channel

        return _ssim(img1, img2, window, self.window_size, channel, self.size_average)


def ssim(img1, img2, window_size=11, size_average=True):
    (_, channel, _, _) = img1.size()
    window = create_window(window_size, channel)

    if img1.is_cuda:
        window = window.cuda(img1.get_device())
    window = window.type_as(img1)
    return _ssim(img1, img2, window, window_size, channel, size_average)

"""#Training"""

import time
os.environ["CUDA_VISIBLE_DEVICES"] = "1"
running_time = time.strftime('%Y-%m-%d-%H-%M-%S')
torch.backends.cudnn.benchmark = True
CROP_SIZE = 256
UPSCALE_FACTOR = 4
NUM_EPOCHS = 10

# train_set = Train_transform('/content/drive/MyDrive/DIV2K_train_HR/DIV2K_train_HR', crop_size=CROP_SIZE, upscale_factor=UPSCALE_FACTOR)
# val_set = Val_transform('/content/drive/MyDrive/DIV2K_valid_HR/DIV2K_valid_HR', upscale_factor=UPSCALE_FACTOR)

train_set = Train_transform('/home/aryan.tomar.20031/akhil/dataset/DIV2K_train_HR', crop_size=CROP_SIZE, upscale_factor=UPSCALE_FACTOR)
val_set = Val_transform('/home/aryan.tomar.20031/akhil/dataset/DIV2K_valid_HR', upscale_factor=UPSCALE_FACTOR)

train_loader = DataLoader(dataset=train_set, num_workers=4, batch_size=16, shuffle=True)
val_loader = DataLoader(dataset=val_set, num_workers=4, batch_size=1, shuffle=False)

netG = Generator()
print('# generator parameters:', sum(param.numel() for param in netG.parameters()))
netD = Discriminator()
print('# discriminator parameters:', sum(param.numel() for param in netD.parameters()))

generator_criterion = GeneratorLoss()
discriminator_criterion = nn.BCELoss()
# import matplotlib.pyplot as plt

# # Define a function to display images side by side
# def show_images(images, titles):
#     num_images = len(images)
#     fig, axes = plt.subplots(1, num_images, figsize=(15, 5))

#     for i in range(num_images):
#         image = images[i].permute(1, 2, 0).numpy()
#         axes[i].imshow(image)
#         axes[i].axis('off')
#         axes[i].set_title(titles[i])

#     plt.show()

# # Display the first batch of images from the training set side by side
# batch = next(iter(train_loader))
# lowres_images, highres_images = batch
# for i in range(5):
#       show_images([lowres_images[i], highres_images[i]],
#                 [f'Low-Resolution Training Image {i+1}', f'High-Resolution Training Image {i+1}'])

# # Display the first batch of images from the validation set side by side
# batch = next(iter(val_loader))
# lowres_images, hr_restore_images, highres_images = batch
# show_images([lowres_images[0], hr_restore_images[0], highres_images[0]],
#             [f'Low-Res Validation Image 1',f'Interpolation' ,f'High-Res Validation Image 1'])

if torch.cuda.is_available():
    netG.cuda()
    netD.cuda()
    generator_criterion.cuda()

optimizerG = optim.Adam(netG.parameters())
optimizerD = optim.Adam(netD.parameters())

results = {'d_loss': [], 'g_loss': [], 'd_score': [], 'g_score': [], 'psnr': [], 'ssim': []}

for epoch in range(1, NUM_EPOCHS + 1):
    train_bar = tqdm(train_loader)
    running_results = {'batch_sizes': 0, 'd_loss': 0, 'g_loss': 0, 'd_score': 0, 'g_score': 0}

    netG.train()
    netD.train()
    for data, target in train_bar:
        g_update_first = True
        batch_size = data.size(0)
        running_results['batch_sizes'] += batch_size

        ############################
        # (1) Update D network: maximize D(x)-1-D(G(z))
        ###########################
        real_img = Variable(target)
        if torch.cuda.is_available():
            real_img = real_img.cuda()
        z = Variable(data)
        if torch.cuda.is_available():
            z = z.cuda()
        fake_img = netG(z)

        netD.zero_grad()
        real_out_ = netD(real_img)
        fake_out_ = netD(fake_img)
        real_out = netD(real_img).mean()
        fake_out = netD(fake_img).mean()
        d_loss_real = discriminator_criterion(real_out_, torch.ones_like(real_out_))
        d_loss_fake = discriminator_criterion(fake_out_, torch.zeros_like(fake_out_))
        d_loss = d_loss_fake + d_loss_real
        d_loss = d_loss_fake + d_loss_real
        d_loss.backward(retain_graph=True)
        optimizerD.step()

        ############################
        # (2) Update G network: minimize 1-D(G(z)) + Perception Loss + Image Loss + TV Loss
        ###########################
        netG.zero_grad()

        fake_img = netG(z)
        fake_out = netD(fake_img).mean()
        g_loss = generator_criterion(fake_out, fake_img, real_img)
        g_loss.backward()

        fake_img = netG(z)
        fake_out = netD(fake_img).mean()

        optimizerG.step()

        # loss for current batch before optimization
        running_results['g_loss'] += g_loss.item() * batch_size
        running_results['d_loss'] += d_loss.item() * batch_size
        running_results['d_score'] += real_out.item() * batch_size
        running_results['g_score'] += fake_out.item() * batch_size

        train_bar.set_description(desc='[%d/%d] Loss_D: %.4f Loss_G: %.4f D(x): %.4f D(G(z)): %.4f' % (
            epoch, NUM_EPOCHS, running_results['d_loss'] / running_results['batch_sizes'],
            running_results['g_loss'] / running_results['batch_sizes'],
            running_results['d_score'] / running_results['batch_sizes'],
            running_results['g_score'] / running_results['batch_sizes']))

    netG.eval()
    out_path = 'training_results/epoch_' + str(epoch) + '/'
    if not os.path.exists(out_path):
        os.makedirs(out_path)

    with torch.no_grad():
        val_bar = tqdm(val_loader)
        valing_results = {'mse': 0, 'ssims': 0, 'psnr': 0, 'ssim': 0, 'batch_sizes': 0}
        val_images = []
        restored_images = []
        for val_lr, val_hr_restore, val_hr in val_bar:
            batch_size = val_lr.size(0)
            valing_results['batch_sizes'] += batch_size
            lr = val_lr
            hr = val_hr
            if torch.cuda.is_available():
                lr = lr.cuda()
                hr = hr.cuda()
            sr = netG(lr)

            batch_mse = ((sr - hr) ** 2).data.mean()
            valing_results['mse'] += batch_mse * batch_size
            batch_ssim = ssim(sr, hr).item()
            valing_results['ssims'] += batch_ssim * batch_size
            valing_results['psnr'] = 10 * log10((hr.max()**2) / (valing_results['mse'] / valing_results['batch_sizes']))
            valing_results['ssim'] = valing_results['ssims'] / valing_results['batch_sizes']
            val_bar.set_description(
                desc='[converting LR images to SR images] PSNR: %.4f dB SSIM: %.4f' % (
                    valing_results['psnr'], valing_results['ssim']))

            restored_images.extend(
                [display_transform()(val_hr_restore.squeeze(0))])

            val_images.extend(
                [display_transform()(val_lr.squeeze(0)), display_transform()(sr.data.cpu().squeeze(0)),
                  display_transform()(hr.data.cpu().squeeze(0))])

        restored_images = torch.stack(restored_images)
        restored_images = torch.chunk(restored_images, restored_images.size(0))
        restored_save_bar = tqdm(restored_images, desc='[saving training results]')
        index = 1
        os.makedirs("outputs", exist_ok=True)
        for image in restored_save_bar:
            image = utils.make_grid(image, padding=5)
            utils.save_image(image, out_path + 'output_%d_index_%d.png' % (epoch, index), padding=5)
            index += 1

        val_images = torch.stack(val_images)
        val_images = torch.chunk(val_images, val_images.size(0) // 3)
        val_save_bar = tqdm(val_images, desc='[saving comparision results]')
        index = 1
        os.makedirs("epochs", exist_ok=True)
        for image in val_save_bar:
            image = utils.make_grid(image, nrow=4, padding=5)
            utils.save_image(image, out_path + 'epoch_%d_index_%d.png' % (epoch, index), padding=5)
            index += 1

    # save model parameters
    os.makedirs("saved", exist_ok=True)
    os.makedirs("statistics", exist_ok=True)
    torch.save(netG.state_dict(), 'epochs/netG_epoch_%d.pth' % (epoch))
    torch.save(netD.state_dict(), 'epochs/netD_epoch_%d.pth' % (epoch))
    # save loss\scores\psnr\ssim
    results['d_loss'].append(running_results['d_loss'] / running_results['batch_sizes'])
    results['g_loss'].append(running_results['g_loss'] / running_results['batch_sizes'])
    results['d_score'].append(running_results['d_score'] / running_results['batch_sizes'])
    results['g_score'].append(running_results['g_score'] / running_results['batch_sizes'])
    results['psnr'].append(valing_results['psnr'])
    results['ssim'].append(valing_results['ssim'])

    if epoch % 10 == 0 and epoch != 0:
        out_path = 'statistics/'
        data_frame = pd.DataFrame(
            data={'Loss_D': results['d_loss'], 'Loss_G': results['g_loss'], 'Score_D': results['d_score'],
                  'Score_G': results['g_score'], 'PSNR': results['psnr'], 'SSIM': results['ssim']},
            index=range(1, epoch + 1))
        data_frame.to_csv(out_path + 'srf_' + str(UPSCALE_FACTOR) + '_train_results.csv', index_label='Epoch')

